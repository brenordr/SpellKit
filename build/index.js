function K(T,O){const j={...T};for(let[k,q]of Object.entries(O))j[k]=(...A)=>{const B=q(...A),I=T.unwrap(),D=B(I);T.publish(D)};return j}var F=()=>{const T=[];let O=!1;return{publish:(j)=>{if(O){console.warn("Attempted to publish to a closed channel");return}T.forEach((k)=>k(j))},subscribe:(j)=>{if(O)throw new Error("Cannot subscribe to a closed channel");return T.push(j),()=>{const k=T.indexOf(j);if(k!==-1)T.splice(k,1)}},close:()=>{O=!0,T.length=0},[Symbol.dispose](){this.close()}}};function G(T){const O=F();let j=T;return O.subscribe((q)=>{j=q}),{...O,unwrap:()=>j}}function L(...T){const O=T.slice(0,-1),j=T[T.length-1],k=j(...O.map((z)=>z.unwrap())),q=G(k),A=()=>{const z=O.map((J)=>J.unwrap());return j(...z)},B=()=>{const z=A();q.publish(z)};O.forEach((z)=>{z.subscribe(()=>B())});const{publish:I,...D}=q;return D}function H(T){return new Proxy({},{get:(O,j)=>{return T.unwrap()[j]},set:(O,j,k)=>{const A={...T.unwrap(),[j]:k};return T.publish(A),!0}})}import{useEffect as M,useState as Q} from"react";function R(T){const[O,j]=Q(T.unwrap());return M(()=>{const k=T.subscribe((q)=>{j(q)});return()=>{k()}},[T]),H(T)}export{R as useStore,H as proxy,G as create,L as computed,F as channel,K as action};
